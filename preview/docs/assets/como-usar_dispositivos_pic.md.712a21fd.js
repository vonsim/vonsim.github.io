import{_ as e,c as a,o,a as i}from"./app.f926d26b.js";const g=JSON.parse('{"title":"PIC","description":"","frontmatter":{},"headers":[{"level":2,"title":"Líneas","slug":"lineas","link":"#lineas","children":[]},{"level":2,"title":"Control","slug":"control","link":"#control","children":[]}],"relativePath":"como-usar/dispositivos/pic.md","lastUpdated":1676134651000}'),n={name:"como-usar/dispositivos/pic.md"},r=i(`<h1 id="pic" tabindex="-1">PIC <a class="header-anchor" href="#pic" aria-hidden="true">#</a></h1><p>El <em>programmable interrupt controller</em> (PIC) es un dispositivo interno que se encuentra entre los dispositvos que emiten <a href="./../interrupciones-por-hardware">interrupciones</a> y la CPU. Como la CPU tiene solo una línea de entrada, este dispositivo se encarga de recibir interrupciones de múltiples dispositivos y multiplexar sus pedidos en esta única línea.</p><h2 id="lineas" tabindex="-1">Líneas <a class="header-anchor" href="#lineas" aria-hidden="true">#</a></h2><p>El PIC cuenta con 8 líneas: de la <code>INT0</code> a la <code>INT7</code> (no todas son utilizadas). Cada línea tiene un registro de 8 bits en la memoria E/S relacionado. La línea <code>INT0</code> tiene la dirección <code>24h</code>, la línea <code>INT1</code> tiene la dirección <code>25h</code>, y así hasta la línea <code>INT7</code>, con la dirección <code>2Bh</code>. En cada uno de estos registros se programará qué ID N le corresponde a cada línea.</p><p>Por ejemplo, sé que la tecla F10 está conectada a la línea <code>INT0</code>. Ahora, quiero que cuando presione la tecla F10 a la CPU le llegue una interrupción con ID N igual a 55. Entonces, escribo 55 en el registro <code>24h</code>: <code>OUT 24h, 55</code>.</p><h2 id="control" tabindex="-1">Control <a class="header-anchor" href="#control" aria-hidden="true">#</a></h2><p>Sabiendo cómo programar las distintas líneas, podemos entender cómo funciona el resto del PIC. Este cuenta con los siguientes registros de 8 bits:</p><ul><li>el registro <code>EOI</code> o <em>end of interrupt</em> (dirección <code>20h</code> de la memoria E/S),</li><li>el registro <code>IMR</code> o <em>interrupt mask register</em> (dirección <code>21h</code> de la memoria E/S),</li><li>el registro <code>IRR</code> o <em>interrupt request register</em> (dirección <code>22h</code> de la memoria E/S),</li><li>y el registro <code>ISR</code> o <em>in-service register</em> (dirección <code>23h</code> de la memoria E/S).</li></ul><p>El primero es el que utilizará la CPU para avisarle al PIO que terminó de procesar la interrupción. Avisa esto escribiendo <code>20h</code> en este registro. Esto es así porque pueden dispararse muchas interrupciones en un lapso corto de tiempo, pero el PIC solo puede emitir una a la vez. Por eso necesita saber cuándo la CPU está libre para recibir otra interrupción.</p><p>El registro <code>IMR</code> denota qué interrupciones están <em>enmascaradas</em>: con un <code>1</code> se enmascaran (es decir, inhabilitan) y con un <code>0</code> se habilitan. Mientras una línea esté enmascarada, no se emitirá la interrupción a la CPU. Cada bit de este registro corresponde con una línea:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">IMR = 7654 3210</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>El bit más significativo corresponde a la línea <code>INT7</code> y el menos significativo a la línea <code>INT0</code>.</p><p>El registro <code>IRR</code> denota las interrupciones pendientes con un <code>1</code> y la ausencia de las mismas con un <code>0</code>. Al igual que en el <code>IMR</code>, cada bit corresponde con una línea.</p><p>Finalmente, el registro <code>ISR</code> denota cuál es la interrupción que está siendo procesada por la CPU.</p>`,14),s=[r];function c(t,d,l,p,u,m){return o(),a("div",null,s)}const I=e(n,[["render",c]]);export{g as __pageData,I as default};
