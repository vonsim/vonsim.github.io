import{_ as e,c as a,o as r,a as s}from"./app.da573a03.js";const _=JSON.parse('{"title":"Interrupciones por hardware","description":"","frontmatter":{},"headers":[{"level":2,"title":"Las subrutinas","slug":"las-subrutinas","link":"#las-subrutinas","children":[]}],"relativePath":"como-usar/interrupciones-por-hardware.md","lastUpdated":1677730224000}'),n={name:"como-usar/interrupciones-por-hardware.md"},o=s('<h1 id="interrupciones-por-hardware" tabindex="-1">Interrupciones por hardware <a class="header-anchor" href="#interrupciones-por-hardware" aria-hidden="true">#</a></h1><p>Las interrupciones por hardware son interrupciones que provienen de los dispotivos e interrumpen a la CPU.</p><p>El simulador cuenta con un <a href="./dispositivos/pic">PIC</a> que se encarga de manejar las interrupciones emitidas por los dispositivos. Una vez estas pasan por el PIC, este le envía la señal de interrupción a la CPU junto a número. Este número es el identificador (ID N) y va desde 0 hasta 255. El PIC determinará el ID N según qué interrupción sucedió.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Al configurar el PIC, preveer que ninguna interrupción tenga un ID N reservado por una <a href="./interrupciones-por-software">interrupción por software</a>, ya que estas utilizan el mismo mecanismo.</p></div><p>Llegado el ID N a la CPU, esta ahora ejecutará una subrutina para manejar esta interrupción. ¿Pero cómo sabe la CPU para saber dónde empieza la subrutina? Esta buscará el inicio de la subrutina en el <strong>vector de interrupciones</strong>. Este vector ocupa las celdas <code>0000h</code> hasta <code>03FFh</code> de la memoria, y cada elemento del vector tiene 4 bytes de largo. Así, el primer elemento se encuentra en <code>0h</code>, el segundo en <code>4h</code>, el tercero en <code>8h</code>, y así. Cada elemento corresponde con la dirección de inicio de la subrutina.</p><p>Por ejemplo, llega la interrupción con ID 9. La CPU leerá las celdas <code>24h</code> y <code>25h</code>, obteniendo una dirección de memoria, y llamará a la subrutina ubicada en esa dirección.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Cada elemento tiene 4 bytes de largo y no 2 por razones históricas.</p></div><p>Con este mecanismo en marcha, mientras la CPU esté ejecutando su programa puede ser interrumpida por los dispositivos y nosotros podemos reaccionar de manera acorde.</p><h2 id="las-subrutinas" tabindex="-1">Las subrutinas <a class="header-anchor" href="#las-subrutinas" aria-hidden="true">#</a></h2><p>Estas subrutinas invocadas por una interrupciones son prácticamente idénticas a las <a href="./subrutinas">subrutinas</a> normales, pero con un par de diferencias:</p><ul><li>al ser llamadas, además de apilarse el retorno en la pila, se apilan los flags del ALU (lo que se denomina <a href="https://es.wikipedia.org/wiki/Program_Status_Word" target="_blank" rel="noreferrer">PSW</a>);</li><li>en vez de retonar con <code>RET</code>, se retorna con <code>IRET</code>.</li></ul>',11),i=[o];function t(c,d,l,u,p,m){return r(),a("div",null,i)}const b=e(n,[["render",t]]);export{_ as __pageData,b as default};
